"""Django views"""

import json
import random
from django.http import HttpResponse
from django.shortcuts import render
from django.shortcuts import redirect
from django.contrib.auth.decorators import login_required
from django.template.defaultfilters import slugify
from django.urls import reverse
from django.db.models import Sum
from . import models


@login_required
def home(request):
    """Short presentation abstract"""
    return render(request, "openy/home.html", {})


@login_required
def settings(request):
    """Control the application behavior"""
    return render(request, "openy/settings.html", {})


def get_position_training_nodes(node, color, partial_threshold=.3):
    if node.is_leaf():
        if node.turn() ^ color:
            return [node], []
        return [], []
    if node.is_pre_leaf():
        if node.turn() ^ color:
            return [node], []
        return [node.children()[0]], []
    buffer, partial = list(), list()
    children = sorted(node.children(), reverse=color)
    if node.turn() == color:
        sub_buffer, sub_partial = get_position_training_nodes(children[0], color)
        buffer += sub_buffer
        partial += sub_partial
        if len(children) > 1 and abs(children[0] - children[1]) < partial_threshold and not children[1].is_leaf():
            partial.append((children[1], get_position_training_nodes(children[1], color)[0]))
    else:
        for child in children:
            sub_buffer, sub_partial = get_position_training_nodes(child, color)
            buffer += sub_buffer
            partial += sub_partial
    return buffer, partial


def build_exercise_moves_to(node, starting_from=None):
    color = node.turn()
    moves = list()
    for ancestor in reversed(node.ancestors()):
        if (starting_from is not None and ancestor.depth() <= starting_from.depth())\
            or ancestor.turn() != color:
            moves.append("0 " + ancestor.move_uci())
        else:
            moves.append("1 " + ancestor.move_uci())
    return ",".join(moves)


def build_position_trainings():
    root = models.Node.objects.filter(parent=None).get()
    position_training_nodes, partial_position_training_nodes = list(), list()
    complete, partial = get_position_training_nodes(root, True)
    position_training_nodes += complete
    partial_position_training_nodes += partial
    complete, partial = get_position_training_nodes(root, False)
    position_training_nodes += complete
    partial_position_training_nodes += partial
    exercises = list()
    position_trainings = list()
    offset = 1
    if models.Exercise.objects.exists():
        offset += models.Exercise.objects.latest("id").id
    for i, node in enumerate(position_training_nodes):
        eid = len(exercises) + offset
        exercises.append(models.Exercise(
            id=eid,
            title="Complete Position #%d" % (i + 1),
            description="This exercise was generated by the Openy trainer.",
            starting_position="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
            cover_position=node.fen,
            moves=build_exercise_moves_to(node),
            first_move=not node.turn(),
        ))
        position_trainings.append(models.PositionTraining(
            exercise_id=eid,
            node_id=node.uid,
            depth=node.depth(),
            partial=False,
        ))
    partial_offset = len(exercises) + offset - 1
    for start, ends in partial_position_training_nodes:
        for end in ends:
            eid = len(exercises) + offset
            exercises.append(models.Exercise(
                id=eid,
                title="Partial Position #%d" % (eid - partial_offset),
                description="This exercise was generated by the Openy trainer.",
                starting_position="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
                cover_position=end.fen,
                moves=build_exercise_moves_to(end, starting_from=start),
                first_move=not end.turn(),
            ))
            position_trainings.append(models.PositionTraining(
                exercise_id=eid,
                node_id=end.uid,
                depth=end.depth(),
                partial=True,
            ))
    models.Exercise.objects.bulk_create(exercises)
    models.PositionTraining.objects.bulk_create(position_trainings)


@login_required
def upload(request):
    """Upload a new repertoire, which overrides any previous data"""
    if request.method == "POST" and request.FILES["file"]:
        models.Exercise.objects.exclude(positiontraining=None).delete()
        models.Node.objects.all().delete()
        data = json.load(request.FILES["file"])
        models.Node.objects.bulk_create([
            models.Node(
                uid=node["uid"],
                fen=node["fen"],
                evaluation=node["ev"],
                comment=node["cmt"],
                label=node["lbl"],
                parent_id=node["p"],
                line=node["line"],
                slug=slugify(node["line"]),
            )
            for node in data
        ])
        build_position_trainings()
    return redirect("openy:settings")


@login_required
def explore(request, slug=""):
    """Explore the node database"""
    if not models.Node.objects.filter(slug=slug).exists():
        return redirect("openy:home")
    node = models.Node.objects.get(slug=slug)
    return render(request, "openy/explore.html", {
        "node": node,
    })


@login_required
def find_entry(request):
    """Check if given a node, a given FEN string corresponds to one of its children"""
    if request.method == "POST" and "fen" in request.POST and "uid" in request.POST:
        children = models.Node.objects.filter(
            parent__uid=int(request.POST["uid"]),
            fen__startswith=request.POST["fen"]
        )
        if children.exists():
            return HttpResponse(
                reverse("openy:explore", kwargs={"slug": children.get().slug}),
                content_type="text/plain"
            )
    return HttpResponse("null", content_type="text/plain")


def get_breadth(root, tree):
    """Compute the maximum breadth of a tree"""
    breadth = dict()

    def set_breadth(uid):
        if uid not in breadth:
            if uid not in tree:
                tree[uid] = list()
                breadth[uid] = 1
            elif len(tree[uid]) == 0:
                breadth[uid] = 1
            else:
                breadth[uid] = sum([set_breadth(child_uid)
                                    for child_uid in tree[uid]])
        return breadth[uid]
    set_breadth(root)
    return breadth


def get_position(root, tree, breadth, params):
    """Compute the positions of nodes before drawing them"""
    def width(uid):
        return (params["radius"] * 2 + params["hmargin"]) * float(breadth[uid])
    position = {root: (0, 0)}

    def set_position(uid):
        for i, child in enumerate(tree[uid]):
            position[child] = [
                position[uid][0]
                - .5 * width(uid)
                + .5 * width(child)
                + sum(width(tree[uid][j]) for j in range(i)),
                position[uid][1] + params["radius"] * 2 + params["vmargin"]
            ]
            set_position(child)
    set_position(root)
    return position


def get_viewbox(position, params):
    """Compute the SVG viewBox given the set of computed node positions"""
    min_x = min([p[0] for p in position.values()])
    max_x = max([p[0] for p in position.values()])
    min_y = min([p[1] for p in position.values()])
    max_y = max([p[1] for p in position.values()])
    return "%.2f %.2f %.2f %.2f" % (
        min_x - params["radius"] - params["hmargin"],
        min_y - params["radius"] - params["vmargin"],
        max_x - min_x + 2 * params["radius"] + 2 * params["hmargin"],
        max_y - min_y + 2 * params["radius"] + 2 * params["vmargin"]
    )


@login_required
def draw(request):
    """Build a SVG from the database"""
    index = {node.uid: node for node in models.Node.objects.all()}
    root, tree = index[int(request.GET.get("center", 0))].tree(
        pred=request.GET.get("pred", None),
        succ=request.GET.get("succ", None)
    )
    params = {
        "radius": float(request.GET.get("radius", 50)),
        "vmargin": float(request.GET.get("vmargin", 20)),
        "hmargin": float(request.GET.get("hmargin", 20)),
        "lines": int(request.GET.get("lines", 0)),
        "bg": int(request.GET.get("bg", 0)),
    }
    breadth = get_breadth(root, tree)
    position = get_position(root, tree, breadth, params)
    content = ""
    for uid, pos in position.items():
        if params["lines"] == 1:
            content += '<g style="stroke: white;">'
        else:
            content += "<g>"
        for child in tree[uid]:
            content += '<line x1="%.2f" y1="%.2f" x2="%.2f" y2="%.2f" />'\
                % (pos[0], pos[1], position[child][0], position[child][1])
        content += "</g>"
        content += "".join([
            '<a class="node" uid="%s" href="%s">'
            % (uid, index[uid].href()),
            '<circle cx="%.2f" cy="%.2f" r="%.2f" fill="%s"/>'
            % (pos[0], pos[1], params["radius"], index[uid].color()),
            '<text x="%.2f" y="%.2f" text-anchor="middle" fill="#FFF" dy=".3em">%s</text>'
            % (pos[0], pos[1], index[uid].label),
            '</a>'
        ])
    style = ""
    if params["bg"] == 1:
        style += 'style="background: #202020; font-family: Segoe UI"'
    return HttpResponse('<svg xmlns="http://www.w3.org/2000/svg" viewBox="%s" %s >%s</svg>' % (
        get_viewbox(position, params),
        style,
        content
    ), content_type="image/svg+xml")


def weighted_choice(population, weights):
    weight_sum = sum(weights)
    choice = random.random()
    for i, element in enumerate(population):
        if sum(weights[:i + 1]) / weight_sum >= choice:
            return element
    return None


@login_required
def train(request):
    if request.method == "POST":
        if "start_custom" in request.POST:
            turn = "turn" not in request.POST
            fen = request.POST["fen"]
            query = models.Node.objects.filter(fen__startswith=fen.split(" ")[0])
            if query.exists():
                start = random.choice(query)
                end = random.choice(get_position_training_nodes(start, turn, 0)[0])
                exercise_obj = models.Exercise.objects.create(
                    title="Custom Exercise #%d"
                    % (models.Exercise.objects.filter(positiontraining=None).count() + 1),
                    description="This exercise was generated by the Openy trainer.",
                    starting_position="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
                    cover_position=start.fen,
                    moves=build_exercise_moves_to(end, starting_from=start),
                    first_move=turn,
                )
                return redirect("openy:exercise", eid=exercise_obj.id)
        elif "start_training" in request.POST:
            trainings = models.PositionTraining.objects.all()
            weights = [
                training.get_training_weight()
                for training in trainings
            ]
            choice = weighted_choice(trainings, weights)
            return redirect("openy:exercise", eid=choice.exercise.id)
    successes = models.PositionTraining.objects.aggregate(Sum("successes"))["successes__sum"]
    failures = models.PositionTraining.objects.aggregate(Sum("failures"))["failures__sum"]
    success_coverage = "%.1f" % (
        100
        * models.PositionTraining.objects.filter(successes__gte=1).count()
        / models.PositionTraining.objects.all().count()
    )
    if failures + successes == 0:
        success_ratio = ""
    else:
        success_ratio = "%.1f" % (100 * successes / (failures + successes))
    return render(request, "openy/train.html", {
        "recent_trainings":
        models.PositionTraining.objects.exclude(last_try=None).order_by("-last_try")[:5],
        "custom_exercises":
        models.Exercise.objects.filter(positiontraining=None).order_by("-date_creation"),
        "total_tries": successes + failures,
        "success_ratio": success_ratio.rstrip("0").rstrip("."),
        "success_coverage": success_coverage.rstrip("0").rstrip("."),
    })


def board(request):
    """Simple board view"""
    return render(request, "openy/board.html", {})


@login_required
def exercise(request, eid):
    if not models.Exercise.objects.filter(id=eid).exists():
        return redirect("openy:train")
    exercise_obj = models.Exercise.objects.get(id=eid)
    return render(request, "openy/exercise.html", {
        "exercise": exercise_obj,
    })


@login_required
def exercise_delete(_, eid):
    if not models.Exercise.objects.filter(id=eid).exists():
        return redirect("openy:train")
    models.Exercise.objects.get(id=eid).delete()
    return redirect("openy:train")


@login_required
def exercise_success(_, eid):
    if not models.Exercise.objects.filter(id=eid).exists():
        return redirect("openy:train")
    exercise_obj = models.Exercise.objects.get(id=eid)
    if hasattr(exercise_obj, "positiontraining"):
        exercise_obj.positiontraining.add_success()
    return redirect("openy:train")


@login_required
def exercise_failure(request, eid):
    if not models.Exercise.objects.filter(id=eid).exists():
        return redirect("openy:train")
    exercise_obj = models.Exercise.objects.get(id=eid)
    if hasattr(exercise_obj, "positiontraining"):
        exercise_obj.positiontraining.add_failure()
        if "progress" in request.GET:
            progress = int(request.GET["progress"]) - 1
            target = list(reversed(exercise_obj.positiontraining.node.ancestors()))[progress]
            return redirect("openy:explore", slug=target.slug)
        return redirect("openy:explore", slug=exercise_obj.positiontraining.node.slug)
    return redirect("openy:train")


@login_required
def graph(request):
    return render(request, "openy/graph.html", {})
